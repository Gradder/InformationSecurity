<!DOCTYPE HTML>

<html>
	<head>
		<title>Security is an important thing</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="icon" href="images/laws/shield.png">
		<link rel="stylesheet" href="assets/css/main.css" />
		<script src="assets/js/jquery-3.3.1.js"></script>
		<script>
		$(function(){
		$("#header").load("header.html");
		$("#here_footer").load("footer.html");
		});
		</script>
	</head>
	<body>

		<div id="header"></div>

		<!-- Banner -->
			<section id="banner">
				<div class="inner">
					<header>
						<h1>Хэш-функция SHA-1</h1>
					</header>

				</div>
			</section>

<br/><br/><br/>
		<!-- Three -->

		<a name="doktrina"></a>


		<div class="row move_left">
			<section class="12u 12u$(large)">
				<h3>Введение</h3>
					<p>Безопасный хэш-алгоритм (Secure Hash Algorithm) был разработан NIST и опубликован в качестве федерального информационного стандарта (FIPS PUB 180) в 1993 году. У алгоритмов MD5 и SHA-1 много общего.
Алгоритм получает на входе сообщение произвольной длины и создает в качестве выхода дайджест сообщения длиной 160 бит.
Алгоритм состоит из следующих шагов:
	</p>
<img src="images/laws/nn.jpg" alt="" class="image_fixer">
	<h1><b>Шаг 1: добавление недостающих битов </b></h1>
	<p>Сообщение добавляется таким образом, чтобы его длина была кратна 448 по модулю 512 (длина = 448 (mod 512)). Добавление осуществля-ется всегда, даже если сообщение уже имеет нужную длину. Таким образом, число добавляемых битов находится в диапазоне от 1 до 512.
Добавление состоит из единицы, за которой следует необходимое количество нулей.
</p>
<h1><b>Шаг 2: добавление длины</b></h1>
	<p>СК сообщению добавляется блок из 64 битов. Этот блок трактуется как беззнаковое 64-битное целое и содержит длину исходного сообщения до добавления.
Результатом первых двух шагов является сообщение, длина которого кратна 512 битам. Расширенное сообщение может быть представлено как последовательность 512-битных блоков Y0, Y1, . . . ,YL-1, так что общая длина расширенного сообщения есть L * 512 бит. Таким образом, результат кратен шестнадцати 32-битным словам.
</p>
<h1><b>Шаг 3: инициализация SHA-1 буфера</b></h1>
	<p>Используется 160-битный буфер для хранения промежуточных и окон-чательных результатов хэш-функции. Буфер может быть представлен как пять 32-битных регистров A, B, C, D и E. Эти регистры инициализируются следующими шестнадцатеричными числами:
</br>A = 67452301
</br>B = EFCDAB89
</br>C = 98BADCFE
</br>D = 10325476
</br>E = C3D2E1F0

</p>
<h1><b>обработка сообщения в 512-битных (16-словных) блоках</b></h1>
	<p>Основой алгоритма является модуль, состоящий из 80 циклических обработок, обозначенный как HSHA. Все 80 циклических обработок имеют одинаковую структуру (рис. 3.6).
Каждый цикл получает на входе текущий 512-битный обрабатываемый блок Yq и 160-битное значение буфера ABCDE, и изменяет содержимое этого буфера.
В каждом цикле используется дополнительная константа Кt которая принимает только четыре различных значения:
</p>
<img src="images/laws/dd.png" alt="" class="image_fixer">
<p>Для получения SHAq+1 выход 80-го цикла складывается со значением SHAq. Сложение по модулю 232 выполняется независимо для каждого из пяти слов в буфере с каждым из соответствующих слов в SHAq.</p>
<img src="images/laws/qq.jpg" alt="" class="image_fixer">	
<h1><b>Шаг 5: выход</b></h1>
<p>После обработки всех 512-битных блоков выходом L-ой стадии является 160-битный дайджест сообщения.
Вот так выглядит логика выполнения отдельного цикла:
</p>
<img src="images/laws/ww.jpg" alt="" class="image_fixer">
<p><b>Рис. 3.7.</b> Логика выполнения отдельного цикла</p>
<p>Каждая элементарная функция получает на входе три 32-битных слова и создает на выходе одно 32-битное слово. Элементарная функция выполняет набор побитных логических операций, т.е. n-ый бит выхода является функцией от n-ых битов трех входов. Функции следующие:
</br>Таблица 3.1</p>
<img src="images/laws/tt.jpg" alt="" class="image_fixer">
<p>На самом деле используются только три различные функции. Для 0 ≤ t ≤ 19 функция является условной: if B then C else D Для 20 ≤ t ≤ 39 и 60 ≤ t ≤ 79 функция создает бит четности. Для 40 ≤ t ≤ 59 функция является истинной, если два или три аргумента истинны.
32-битные слова Wt получаются из очередного 512-битного блока сообщения следующим образом.</p>
<img src="images/laws/uu.jpg" alt="" class="image_fixer">
<p><b>Рис. 3.9.</b> Получение входных значений каждого цикла из очередного блока</p>
<p>Первые 16 значений Wt берутся непосредственно из 16 слов текущего блока. Оставшиеся значения определяются следующим образом:</p>
 <img src="images/laws/ii.png" alt="" class="image_fixer">
<p>В первых 16 циклах вход состоит из 32-битного слова данного блока. Для оставшихся 64 циклов вход состоит из XOR нескольких слов из блока сообщения.</p>

<div id="here_footer"></div>


		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
