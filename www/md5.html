<!DOCTYPE html>
<!-- saved from url=(0029)http://fspoib.tk/algo_a5.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Security is an important thing</title>
		
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="icon" href="http://fspoib.tk/images/laws/shield.png">
		<link rel="stylesheet" href="assets/css/main.css">
		<script src="jquery-3.3.1.js"></script>
		<script>
		$(function(){
		$("#header").load("header.html");
		$("#here_footer").load("footer.html");
		});
		</script>
		<style type="text/css">
			.abzac {
				text-indent: 25px;
			}
			.etap {
				font-size: 20px;
				font-weight: bold;
			}
			.box p {
				margin-bottom: 0px;
			}
			.box {
				background-color: rgba(144, 144, 144, 0.075);
				min-width: 100px;
				display: inline-block;
			}
			.formula {
				margin-bottom: 0px;
			}
			.obvodka {
				/*border: 1px solid grey;*/
				padding: 5px 10px;
				margin-top: 0px;
			}
			.text {
				float: left;
			}
			.cartinka {
				float: right;
				margin-left: 10px;
			}
			.border {
				border: solid 1px grey;
				padding: 0px;
				text-align: center;
				min-width: 320px;
			}
			.podpis {
				margin-top: 10px;
				margin-bottom: 10px;
			}
			.spisok {
				font-size: 20px;
				font-weight: 500;
			}
		</style>
	</head>
	<body class="">

		<div id="header">			<header id="header">
				<div class="inner">
					<a href="http://fspoib.tk/index.html" class="logo"><strong>Security</strong> is an important thing</a>
					<nav id="nav">
						<a href="http://fspoib.tk/index.html">Главная</a>
						<a href="http://fspoib.tk/progress_board.html">Прогресс</a>
						<a href="http://fspoib.tk/elements.html">Элементы</a>
					</nav>
					<a href="http://fspoib.tk/algo_a5.html#navPanel" class="navPanelToggle"><span class="fa fa-bars"></span></a>
				</div>
			</header>
</div>

		<!-- Banner -->
			<section id="banner">
				<div class="inner">
					<header>
						<h1>Алгоритм хеширования MD5</h1>
					</header>

				</div>
			</section>

<br><br><br>
		<!-- Three -->

		<a name="doktrina"></a>


		<div class="row move_left">

	<section class="11u 12u$(medium)">
		<h3>История возникновения</h3>
		<p class="abzac"><strong>MD5</strong> (англ. <i>Message Digest 5</i>) — 128-битный алгоритм хеширования, разработанный профессором Рональдом Л. Ривестом из Массачусетского технологического института (Massachusetts Institute of Technology, MIT) в 1991 году. Предназначен для создания «отпечатков» или дайджестов сообщения произвольной длины и последующей проверки их подлинности. Широко применялся для проверки целостности информации и хранения хешей паролей.</p>
		<p class="abzac">Был разработан в 1991 году как более надёжный вариант предыдущего алгоритма MD4. Описан в <a href="https://rfc2.ru/1321.rfc" target="_blank">RFC 1321</a>. Позже Гансом Доббертином были найдены недостатки алгоритма MD4.</p>
		<p class="abzac">В 1993 году Берт ден Бур (Bert den Boer) и Антон Босселарс (Antoon Bosselaers) показали, что в алгоритме возможны псевдоколлизии, когда разным инициализирующим векторам соответствуют одинаковые дайджесты для входного сообщения.
		В 1996 году Ганс Доббертин (Hans Dobbertin) объявил о коллизии в алгоритме, и уже в то время было предложено использовать другие алгоритмы хеширования, такие как Whirlpool, SHA-1 или RIPEMD-160.
		Из-за небольшого размера хеша в 128 бит можно рассматривать birthday-атаки.</p>
		<p class="abzac">18 марта 2006 года исследователь Властимил Клима (Vlastimil Klima) опубликовал алгоритм, который может найти коллизии за одну минуту на обычном компьютере, метод получил название «туннелирование».
		В конце 2008 года US-CERT призвал разработчиков программного обеспечения, владельцев веб-сайтов и пользователей прекратить использовать MD5 в любых целях, так как исследования продемонстрировали ненадёжность этого алгоритма.</p>
	</section>

	<section class="11u 12u$(medium)">
		<h3>Схема работы</h3>
		<section class="3u 3u$(small) cartinka">
			<div class="border">
			<img src="md5.png" class="image_lectures">
			<p class="podpis">Схема работы алгоритма MD5</p>
			</div>
		</section>
		<section class="9u 9u$(medium) tekst">
			<p class="abzac">На вход алгоритма поступает входной поток данных, хеш которого необходимо найти. Длина сообщения измеряется в битах и может быть любой (в том числе нулевой). Запишем длину сообщения в <i>L</i>. Это число целое и неотрицательное. Кратность каким-либо числам необязательна. После поступления данных идёт процесс подготовки потока к вычислениям.</p>
		</section>
				<h3 class="spisok">1. Выравнивание потока.</h3> <p>Сначала к концу потока дописывают единичный бит. Затем добавляют некоторое число нулевых бит такое, чтобы новая длина потока <i><strong>L'</strong></i> стала сравнима с 448 по модулю 512, (<i><strong>L' = 512 × N + 448</strong></i>). Выравнивание происходит в любом случае, даже если длина исходного потока уже сравнима с 448.</p></li>
				<h3 class="spisok">2. Добавление длины сообщения.</h3> <p>В конец сообщения дописывают 64-битное представление длины данных (количество бит в сообщении) до выравнивания. Сначала записывают младшие 4 байта, затем старшие. Если длина превосходит <i><strong>2<sup>64</sup>-1</strong></i> , то дописывают только младшие биты (эквивалентно взятию по модулю <i><strong>2<sup>64</sup></strong></i> ). После этого длина потока станет кратной 512. Вычисления будут основываться на представлении этого потока данных в виде массива слов по 512 бит.</p>
				<h3 class="spisok">3. Инициализация буфера.</h3> <p>Для вычислений инициализируются 4 переменных размером по 32 бита и задаются начальные значения шестнадцатеричными числами (порядок байтов little-endian, сначала младший байт):</p>
					<div class="box">
						<p>А = 01 23 45 67; // 67452301h</p>
						<p>В = 89 AB CD EF; // EFCDAB89h</p>
						<p>С = FE DC BA 98; // 98BADCFEh</p>
						<p>D = 76 54 32 10. // 10325476h</p>
					</div>
				<p class="abzac">В этих переменных будут храниться результаты промежуточных вычислений. Начальное состояние ABCD называется инициализирующим вектором.</p><p>Определим ещё функции и константы, которые нам понадобятся для вычислений.</p>
				<ul>
					<li>Потребуются 4 функции для четырёх раундов. Введём функции от трёх параметров — слов, результатом также будет слово:
						<p class="formula">1-й раунд: <strong>FunF(X,Y,Z) = (X ∧ Y) ∨ (¬X ∧ Z)</strong>,</p>
						<p class="formula">2-й раунд: <strong>FunG(X,Y,Z) = (X ∧ Y) ∨ (¬Z ∧ Y)</strong>,</p>
						<p class="formula">3-й раунд: <strong>FunH(X,Y,Z) = (X ⊕ Y ⊕ Z)</strong>,</p>
						<p class="formula">4-й раунд: <strong>FunI(X,Y,Z) = Y ⊕ (¬Z ∨ X)</strong>,</p>
						<p class="formula">где ⊕ ,∧ ,∨ ,¬  побитовые логические операции XOR, AND, OR и NOT соответственно.</p></li>
					<li>Определим таблицу констант <strong>T[1...64]</strong> — 64-элементная таблица данных, построенная следующим образом: <strong>T[n] = int(2<sup>32</sup> ⋅ |sin n|).</strong></li>
					<li>Каждый 512-битный блок проходит 4 этапа вычислений по 16 раундов. Для этого блок представляется в виде массива X из 16 слов по 32 бита. Все раунды однотипны и имеют вид: [abcd k s i], определяемый как <strong>a = b + ((a + Fun(b,c,d) + X[k] + T[i]) <<< s)</strong>, где k — номер 32-битного слова из текущего 512-битного блока сообщения, и <strong>... <<< s</strong> — циклический сдвиг влево на s бит полученного 32-битного аргумента. Число s задается отдельно для каждого раунда.</li>
				</ul>
				<h3 class="spisok">4. Вычисление в цикле.</h3> <p>Заносим в блок данных элемент n из массива 512-битных блоков. Сохраняются значения A, B, C и D, оставшиеся после операций над предыдущими блоками (или их начальные значения, если блок первый).</p>
					<div class="box">
					<p>AA = A</p>
					<p>BB = B</p>
					<p>CC = C</p>
					<p>DD = D</p>
					</div>
					<p class="etap">Этап 1</p>
					<div class="box">
						<p>/* [abcd k s i] a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */</p>
						<p>[ABCD  0 7  1][DABC  1 12  2][CDAB  2 17  3][BCDA  3 22  4]</p>
						<p>[ABCD  4 7  5][DABC  5 12  6][CDAB  6 17  7][BCDA  7 22  8]</p>
						<p>[ABCD  8 7  9][DABC  9 12 10][CDAB 10 17 11][BCDA 11 22 12]</p>
						<p>[ABCD 12 7 13][DABC 13 12 14][CDAB 14 17 15][BCDA 15 22 16]</p>
					</div>
					<p class="etap">Этап 2</p>
					<div class="box">
						<p>/* [abcd k s i] a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */</p>
						<p>[ABCD  1 5 17][DABC  6 9 18][CDAB 11 14 19][BCDA  0 20 20]</p>
						<p>[ABCD  5 5 21][DABC 10 9 22][CDAB 15 14 23][BCDA  4 20 24]</p>
						<p>[ABCD  9 5 25][DABC 14 9 26][CDAB  3 14 27][BCDA  8 20 28]</p>
						<p>[ABCD 13 5 29][DABC  2 9 30][CDAB  7 14 31][BCDA 12 20 32]</p>
					</div>
					<p class="etap">Этап 3</p>
					<div class="box">
						<p>/* [abcd k s i] a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */</p>
						<p>[ABCD  5 4 33][DABC  8 11 34][CDAB 11 16 35][BCDA 14 23 36]</p>
						<p>[ABCD  1 4 37][DABC  4 11 38][CDAB  7 16 39][BCDA 10 23 40]</p>
						<p>[ABCD 13 4 41][DABC  0 11 42][CDAB  3 16 43][BCDA  6 23 44]</p>
						<p>[ABCD  9 4 45][DABC 12 11 46][CDAB 15 16 47][BCDA  2 23 48]</p>
					</div>
					<p class="etap">Этап 4</p>
					<div class="box">
						<p>/* [abcd k s i] a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */</p>
						<p>[ABCD  0 6 49][DABC  7 10 50][CDAB 14 15 51][BCDA  5 21 52]</p>
						<p>[ABCD 12 6 53][DABC  3 10 54][CDAB 10 15 55][BCDA  1 21 56]</p>
						<p>[ABCD  8 6 57][DABC 15 10 58][CDAB  6 15 59][BCDA 13 21 60]</p>
						<p>[ABCD  4 6 61][DABC 11 10 62][CDAB  2 15 63][BCDA  9 21 64]</p>
					</div>
					<p>Суммируем с результатом предыдущего цикла:</p>
					<div class="box">
						<p>A = AA + A</p>
						<p>B = BB + B</p>
						<p>C = CC + C</p>
						<p>D = DD + D</p>
					</div>
					<p>После окончания цикла необходимо проверить, есть ли ещё блоки для вычислений. Если да, то переходим к следующему элементу массива <i>(n + 1)</i> и повторяем цикл.</p>
				<h3 class="spisok">5. Результат вычислений.</h3> <p>Результат вычислений находится в буфере ABCD, это и есть хеш. Если выводить побайтово, начиная с младшего байта A и закончив старшим байтом D, то мы получим MD5-хеш. 1, 0, 15, 34, 17, 18…</p>
			</ol>	
	</section>

	<section class="11u 12u$(medium)">
		<h3>Сравнение MD5 и MD4</h3>
		<p class="abzac">Алгоритм MD5 происходит от MD4. В новый алгоритм добавили ещё один раунд, теперь их стало 4 вместо 3 в MD4. Добавили новую константу для того, чтобы свести к минимуму влияние входного сообщения, в каждом раунде на каждом шаге и каждый раз константа разная, она суммируется с результатом F и блоком данных. Изменилась функция <i><strong>G = XZ ∨ (Y¬Z)</strong></i> вместо <i><strong>XY ∨ XZ ∨ YZ</strong></i> . Результат каждого шага складывается с результатом предыдущего шага, из-за этого происходит более быстрое изменение результата. Для этой же цели оптимизирована величина сдвига на каждом круге. Изменился порядок работы с входными словами в раундах 2 и 3.</p>
		<p><strong>Пример MD5:</strong> (Хеш содержит 128 бит (16 байт) и обычно представляется как последовательность из 32 шестнадцатеричных цифр)</p>
		<p class="box obvodka">MD5("md5") = 1BC29B36F623BA82AAF6724FD3B16718</p>

	</section>
	<section class="11u 12u$(medium)">
		<h3>Примеры использования</h3>
			<p class="abzac">Ранее считалось, что MD5 позволяет получать относительно надёжный идентификатор для блока данных. На данный момент данная хеш-функция не рекомендуется к использованию, так как существуют способы нахождения коллизий с приемлемой вычислительной сложностью. Свойство уникальности хеша широко применяется в разных областях. Стоит отметить, что приведенные примеры относятся и к другим криптографическим хеш-функциям.</p>
			<p class="abzac">С помощью MD5 проверяли целостность и подлинность скачанных файлов — так, некоторые программы поставляются вместе со значением контрольной суммы. Например, пакеты для инсталляции свободного ПО.</p>
			<p class="abzac">MD5 использовался для хеширования паролей. В системе UNIX каждый пользователь имеет свой пароль и его знает только пользователь. Для защиты паролей используется хеширование. Предполагалось, что получить настоящий пароль можно только полным перебором. При появлении UNIX единственным способом хеширования был DES (Data Encryption Standard), но им могли пользоваться только жители США, потому что исходные коды DES нельзя было вывозить из страны. Во FreeBSD решили эту проблему. Пользователи США могли использовать библиотеку DES, а остальные пользователи имеют метод, разрешённый для экспорта. Поэтому в FreeBSD стали использовать MD5 по умолчанию. Некоторые Linux-системы также используют MD5 для хранения паролей.</p>
			<p>Многие системы используют базы данных для аутентификации пользователей и существует несколько способов хранения паролей:</p>
			<ol>
				<li>Пароли хранятся как есть. При взломе такой базы все пароли станут известны.</li>
				<li>Хранятся только хеши паролей. Найти пароли можно используя заранее подготовленные таблицы хешей. Такие таблицы составляются из хешей простых или популярных паролей.</li>
				<li>К каждому паролю добавляется несколько случайных символов (их называют «соль») и результат хешируется. Полученный хеш вместе с «солью» сохраняются в открытом виде. Найти пароль с помощью таблиц таким методом не получится.</li>
			</ol>
			<p>Существует несколько надстроек над MD5.</p>
			<ul>
				<li><strong>MD5 (HMAC)</strong> — Keyed-Hashing for Message Authentication (хеширование с ключом для аутентификации сообщения) — алгоритм позволяет хешировать входное сообщение L с некоторым ключом K, такое хеширование позволяет аутентифицировать подпись.</li>
				<li><strong>MD5 (Base64)</strong> — здесь полученный MD5-хеш кодируется алгоритмом Base64.</li>
				<li><strong>MD5 (Unix)</strong> — алгоритм вызывает тысячу раз стандартный MD5, для усложнения процесса. Также известен как MD5crypt.</li>
			</ul>
	</section>
</div>



<div id="here_footer">
		<!-- Footer -->
		<footer id="myfooter">
	<h3 class="flexcontainer">Ссылки на всё</h3>
	<div class="flexcontainer"><i onclick="window.open(&#39;https://github.com/Gradder/InformationSecurity&#39;+location.search)" class="icon fa-github fa-5x footer_hover"></i>  <i style="margin-left: 120px;" onclick="window.open(&#39;https://drive.google.com/drive/u/1/folders/1ucCxv6MTJeCxI35UvBbHgo5u8_-LHYNL&#39; + location.search)" class="icon fa-cloud-download fa-5x footer_hover"></i></div>


				<div class="flexcontainer" style="margin-top:-20px; margin-left:20px;">
						© Roman Zhitkov

					<span style="margin-left:60px;">Email: rvzhitkov@gmail.com</span>
					</div>


			</footer>
</div>


		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	

<div id="navPanel">undefined<a href="http://fspoib.tk/hash_md5.html#navPanel" class="close" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></a></div></body></html>